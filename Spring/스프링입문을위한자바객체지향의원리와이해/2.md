# 2. 자바와 절차적/구조적 프로그래밍

* 현실세계 VS 자바  
    - JDK : JVM용 소프트웨어 개발도구 / 소프웨어 개발 도구
    - JRE : JVM용 OS                / 운영체제
    - JVM : 가상의 컴퓨터            / 하드웨어(물리적 컴퓨터)

* JDK
- 자바 개발 도구이며 자바 컴파일러(javac.exe)를 포함

* JRE
- 자바 실행 환경이며 자바 실행기(java.exe)를 호함

* JVM
- 자바 가상 기계

* `JDK > JRE > JVM`
    <BR>=> JDK가 JRE를 포함하고 JRE가 JVM을 포함하고 있다.
 
 ## 메모리 사용 방식
모든 프로그램에서 프로그램이 실행될 때 메모리를 사용하는 방식은
두 영역으로 나뉘어져 있다
- 코드 실행 영역
- 데이터 저장 영역

<b>그러나 객체지향프로그램에서의 메모리 사용방식은 다르다.</B>
- 코드 실행 영역
- 데이터 저장 영역
    - static/method 영역 (클래스들의 놀이터)
    - stack 영역  (메소드들의 놀이터)
    - heap 영역(객체들의 놀이터)

- JRE는 프로그램 안에 main() 있는지 확인 
- main()이 확인되면 JVM(가상기계)에 전원을 넣어 부팅한다.
- 부팅된 JVM은 목적 파일을 받아서 전처리 과정 실행
    - 전처리 과정
        1) java.lang 패키지를 static 영역에 배치
        2) 개발자가 작성한 모든 클래스, import 패키지를 static 영역에 배치
- 메모리 구조 만들어지면 main() 메서드 스택프레임에 배치, 변수 공간 배치

- main()은 프로그램의 끝이므로 main()이 끝나면
JRE는 JVM을 종료하고 JRE 자체도 운영체제 상의 메모리 상에서 사라진다.

</hr>

## 지역변수
- 스택 영역
- Call by value
```
main(String[] args){

    int k = 5;
    m = test(k)
}

test(int k){
    int result ;
    k = 25;
}
```
main과 test는 별도의 스택프레임이 생성되며 
별도의 스택프레임에 생성된 변수(k)이기 떄문에
k는 독립적으로 존재한다. 

## 클래스 변수
- 스태틱 영역
- 한 번 자리잡으면 JVM이 종료될 때까지 존재

## 객체 멤버
- 힙
- 가비지컬렉터에 메모리 회수되기 전까지 존재

## 메모리 구조 관련 질문 정리?

- 1) main() 메소드 안에 soutm만 있는 경우의 메모리 구조 그림 그려보기
- 2) 메모리구조 관점에의 지역변수
- 3) if() 분기 관련 블록 스택 프레임
    - 메소드 프레임 안의 블록프레임에서 메소드 프레임 접근 가능
        - 메소드 프레임 내부에 블록프레임이 있기 때문에 가능
    - 메소드 프레임에서 블록프레임 접근은 불가능
- 4) 메소드 > 메소드 호출할 경우
- 5) 전역변수가 있는 경우
    - 스택 프레임이 종속적인 지역변수
    - 스택 프레임에 독립적인 전역변수
    - `전역변수`는 `값이 공유`되기 때문에 `어디서 변경됐는지 파악이 힘들기` 떄문에 조심해서 사용할 것!! `읽기 전용`으로 쓰이는 것은 강추!!
- 6) 메모리 관점에서 지역변수를 초기화가 필요한 이유?
    - 지역변수의 경우, 이전에 해당공간의 메모리를 사용핶던 다른 프로그램이 청소하지 않은 값을 가짐    

## 멀티스레드/멀티 프로세스
* 멀티프로세스
    - 다수의 데이터 저장 영역(T메모리)를 갖는 구조
    - 각 프로세스마다 각자의 T메모리가 있으며 독립적인 공간이므로 서로 참조 불가능
    - 하나의 프로세스가 다른 프로세스의 T메모리 영역 침범 불가
* 멀티스레드
    - 멀티스레드는 stack 영역을 스레드 갯수만큼 분할해서 사용
    - 하나의 스레드 안에서 다른 stack은 접근할 수 없지만 static과 heap을 공유한다.
    - 멀티프로세스 대비 메모리를 적게 사용할 수 있는 구조

## 클래스 로더와 스태틱(메소드) 영역
- JVM의 클래스 로더가 스태틱 영역에 배치한다.(로딩, 링크, 초기화 중 `로딩` 작업)
    - java.lang 패키지
    - import된 패키지
    - 클래스 수준의 정보
        - 개발자가 작성한 모든 클래스
        - 클래스 안의 변수
        - 클래스 안의 메소드들
        - 부모클래스
- 로딩이 끝나면 클래스 타입의 객체를 heap에 생성한다.

```
public class Test{
	public void static main(String[] args){
		Test.class
	}
}
```
`Test.class`로 접근이 가능하다!!











    

