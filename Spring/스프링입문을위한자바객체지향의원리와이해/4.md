# 4. 자바가 확장한 객체지향

## 추상 메서드와 추상 클래스
- 추상 메소드 없이도 추상 클래스 선언이 가능
- 추상 클래스는 new를 사용할 수 없다
- 추상 메서드는 하위 클래스에서 구현을 강제한다
- 추상 메서드를 포함하는 클래스는 추상 클래스여야 한다

## 생성자
- 생성자도 메소드다.
- 생성자 별도 정의 안했다면 자동으로 생성한다
- 인자가 있는 생성자가 있다면 기본 생성자를 만들지 않는다.
## static 블록

- 클래스가 static 영역에 배치될 떄 실행되는 블록
- static 블록에서 사용할 수 있는 속성과 메소드는 당연히 static 멤버 뿐
- 해당 static 클래스가 처음으로 사용될 떄 static 영역에 배치되면서 단 한번만 실행된다.
    - 클래스의 정적 속성 사용
    - 클래스의 정적 메서드 사용
    - 클래스의 인스턴스 최초로 만들때
- `static 영역은 한 번 올라가면 프로그램 종료될 때까지는 해당 메모리 반환이 안되기 때문`에 최대한 늦게 로딩하기 위해서 클래스가 처음으로 사용될 떄 static 영역에 배치한다.
- 실무에선 static 블록 사용할 일이 없다.
## final
- final 클래스
    - 상속 불가
- final 변수
    - 값 변경 불가
- final 메서드
    - 오버라이딩 불가
## instance of
- 객체가 특정 클래스인지 물어보는 연산자
- LSP(리스코프 치환 법칙)을 어기는 코드에서 나타남

## package
    - 네임스페이스

## interface, implements
- public 추상메서드와 public 정적 상수만 가질 수 있다.
```
interface aa
{
    public static final double PI = 3.141592;
    public abstract void aa();

}
```

## this 키워드
```
class AA{
    int abcd = 10;
    
    void test(){
        int abcd = 20;
        System.out.println(abcd);   // 20 출력
         System.out.println(this.abcd); // 10 출력
    }
}
```
- 지역변수vs객체변수 이름이 같은 경우 지역변수가 우선된다.
- 지역변수vs객체변수 이름이 같은 경우, 객체변수 사용하려면 this 사용

## super 키워드
상위 클래스의 인스턴스를 지징하는 키워드

## 객체메서드 호출 시, 클래스명.객체메서드명인 이유?
- 객체 메서드는 각 객체별로 달라지는 것이 아니다.
- 객체 멤버의 속성은 달라질 수있으나, 객체 메서드는 각 객체별로 달라지는게 아니다.
즉 `객체의 수만큼` `객체 메서드를 생성`하는 것은 심각한 메모리 `낭비`
이다.
> JVM은 객체 멤버의 메서드를 static 영역에 보유한다.
