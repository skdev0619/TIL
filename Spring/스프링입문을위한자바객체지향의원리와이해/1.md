# 1. 사람이 사랑한 기술
## 스프링을 대표하는 키워드
- SOA
- CBD
- OOP
- 절자적/구조적 프로그래밍
- 기계어/어셈블리어

## 기계어
1. 기계어
    - 기계가 이해하는 유일한 언어
    - 기계어는 CPU마다 다르기 떄문에 이기종 간의 호환이 불가능하다
    ex) 인텔, ARM 각각 전용의 기계어가 존재하며 인텔 기계어는 인텔에서만 실행 가능하고 ARM 또한 마찬가지다.

2. 어셈블리어
    - 기계어 명렁어와 일상용어를 일대일로 매칭하는 코드표
    - 한계
    > CPU마다 기계어가 다르기 떄문에 CPU마다 어셈블리어가 다르다.
    마찬가지로 어셈블리어를 해석하는 에셈블로 또한 CPU마다 별도로 존재한다.


3. C언어
    - `컴파일러`의 등장과 함께 `강력한 이식성` 제공 
    - 어셈블리어의 경우 기계의 개수만큼 언어의 개수가 있었으나
    C언어가 생기면서 소스파일이 하나로 변경
    - 어떤 CPU인지 알 필요는 없으나 그 부담을 컴파일러로 넘겼다.
    > ex) 인텔 컴파일러, ARM 컴파일러
    - 하나의 파일을 기계에 맞는 컴파일러로 컴파일하면 각 기계에 맞는 기계어 목적파일이 생긴다.

    
    ※ 운영체제와 링커
    - 어셈블리어가 CPU에 종속적인 것처럼 실행파일 또한 같은 CPU를 사용하더라도 OS에 종속적이다. 
    - 기계어인 목적 코드를 특정 운영체제의 실행파일로 만들기 위해서는 특정 운영체제의 포맷에 맞춰서 구성해야 한다.
    > 이 역할을 하는게 `링커`다.

    * 링커란 ?
    > 어셈블러가 생성한 목적 파일들을 결합하여 하나의 실행 파일로 만드는 작업

    * 실행파일이란?
    > CPU에게 일을 시키기 위한 바이너리 형태의 명령어를 운영체제에서 요구하는 포맷에 맞춰 구성한 파일

    * 실행파일이 만들어지는 단계
    ```
    소스파일 -> 컴파일러 -> 어셈블리어 -> 어셈블러 -> 오브젝트 파일(목적 파일) -> 링커 -> 실행 파일
    ```

    * C언어의 한계
    - 운영체제별 특성으로 인해서 컴파일 전 운영체제별로 소스 수정이 필요하다.
    ex) int 2byte, 4byte로 각각 인지가 다르다.
    > 소스 코드 작성 > 운영코드별 소스 수정 > 컴파일
    - 기계어/어셈블리어 대비 느리다<br>
    => 비교적 CPU, 메모리 자원을 효율적으로 사용을 못함

4. C++ (객체지원언어)
- C + 객체지향 개념 도입
- 객체지원언어
> 클래스 없이 메소드 작성이 가능하다.

5. JAVA (객체지향언어)
- 컴파일러를 기종별로 준비할 필요가 없으나 해당 기종용 JRE가 설지되어야 한다.
- JVM(자바가상기계)은 가상의 컴퓨터를 물리적 컴퓨터의 메모리 안에 하나 더 구축하는 것이기 때문에 물리적 CPU, 메모리 자원을 많이 소비한다.<br>
=> C/C++에 베해 느린 건 맞으나 하드웨어의 발전, 최적화된 알고리즘 반영된 API, JVM으로 인해서 많이 좋아졌다.
