# 트랜잭션
여러 쿼리문을 마치 하나의 오퍼레이션으로 묶을 수 있어야 한다.
처리 중 일부만 실패해서 데이터 정합성이 꺠질 수 있음

# 트랜잭션 격리레벨
처리 중인 데이터를 다른 곳에서 조회하게 되서 데이터 정합성이 깨짐
-> 이를 보장위한 `트랜잭션 격리레벨`

A(원자성) 
    - 원자적 연산을 보장해야 한다.
    - All or Nothing(무조건 성공 아님 실패)
    - 어떻게? Mysl(MVCC)
    
    - inno db 메모리에 원본 데이터에 업데이트
    - 원래 데이터는 Undo Log에 보관
    - 트랜잭션 실패면 Undo Log통해서 rollback실행
    - Undo Log를 통해서 Atomic함 보장
    - 트랜잭션 커밋 후 Undo를 바로 삭제하지는 않는다
        해당 트랜잭션보다 먼저 시작하고 늦게 끝나서 Undo Log를 바라보는 트랜잭션이 있을 수 도 있음 바라볼 가능성이 있어서 나눈다
    - 트랜잭션이 아토믹시티한 단위가 된다.


C(일관성)
 - 트랜잭션 종료되었을 떄 데이터 무결성 보장
 - 어떻게 ? 제약조건 통해서 
    ex) 유니크, 외래키 제약 등 
 - 어떤 트랜잭션이등 이러한 제약을 깨고 성공, 실패할 수는 없다

 - mysql 어떻게 유니크 제약 유지하는지 따로 찾아볼 것
 
I(독립성) 
    - 서로 간섭하지 않고 독립적으로 동작한다
    - 높은 동시성 많은 성능을 포기해야 하므로 개발자가 제어 가능
    - 트랜잭션 격리레벨 undo mvcc
    - 지원하는 db에서 따라 조금씩 다름
D(지속성)
    - 완료된 트랜잭션은 유실되지 않는다
    - WAL(순차적으로 로그 저장 후, 어떤 식으로 컴퓨터 꺼져서 메모리 날라가면 WAL로그 통해서 디스크에 넣는다)
    랜덤한 IO를 줄이는게 성능 핵심
    INSERT, UPDATE할 때마다 디스크에 데이터 넣는 건 성능 저하
    먼저 메모리에 데이터를 쓴다

@TRAN



대용량 시스템에서는 트랜잭션 걸 떄 고민
게시물 하나 작성 팔로워 몇 만명
트랜잭션이 겁나 길어짐
undo log를 유지하는 시간 길어짐
rock 잡으면 성능에도 안좋음
트랜잭션 범위를 짧게 잡아주도록 하자

이미지 업로드 같은 경우
aws s3 네트워크에 따라 트랜잭션이 길어질 수있음
외부 요인에 따라 트랜잭션 길어지는 건 배제
트랜잭션 길어지면 커넥션 오랫동안 점유하면 동시다발적이면 커넥션 풀 고갈
트랜잭션 기간동안 커넥션 풀 점유

propagation level
선언전 트랜잭션의 경우 트랜잭션간의 관계를 제어하는데
트랜잭션 텝플릿보다는 자유롭지 못한데 그 한계를 극복하고자 propagation가 있음

트랜잭션안의 트랜잭션이 어떻게 동작한느지 선언이 가능

## 격리레벨
isolation - 트랜잭션은 서로 간섭하지 않고 독립적으로 동작
- 성능 이슈로 개발가 선택 가능


- dirty read
커밋되지 않은 데이터 읽음
non repatabel read
- 하나의 트랜잭션에서 같은 데이터 읽었는데
결과가 달라짐

팬텀리드
- 같은 조건으로 데이터 읽었는데 없던 데이터가 생긴 문제

표로 정리할 것

시리얼로 갈 수록 이상현상 없으나
동시처리량 낮아짐

uncommit, serial 거의 안씀
commit - 제일 많인 쓴다
repeat - get rock 같은 이슈 데드락이 발생한다
lost update
read secure
write secure







